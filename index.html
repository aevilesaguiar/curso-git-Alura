<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curso Git</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>

<h1>O que é Git?</h1>
<p>Git é um controle de Versão</p>
<p>Existem diversos outros sistemas de versão. Segue algumas alternativas:</p>
<ul>
    <li>CVS</li>
<li>SVN</li>
<li>Mercurial</li>
</ul>
<p>O git é o mais utilizado entre eles atualmente por conta de algumas características, como por exemplo permitir uma cópia do projeto,criar um repositório do projeto em sua máquina, para que seja possivel trabalhar em cima dela e se houver necessidade também enviar para outro repositório.</p>

<hr>
<h2>O projeto do Curso será uma pagina html simples</h2>

<p>Para inicializar um repositorio utilizamos o comando: <b>git init</b></p>

<p>Todas as alterações que forem realizadas nos arquivos dentro deste repositório poderão ser mostradas  pelo o Git, com indicações que foi
    modificado, quem modificou , quando foi modificado e assim por diante.
</p>

<p>Um comando que mostra o estado do repositório, ou seja , quais arquivos foram alterados , ou não é o <b>git status</b></p>
 
<hr>
<p>
    Neste tópco aprendemos:
</p>
<ul>
    <li>O que são (e para que servem) sistemas de controle de versões e como eles podem ajudar o nosso fluxo de desenvolvimento,
        nos ajudando a manter um histórico de alterações,controle sobre cada alteração no código
    </li>
    <li>O que é o Git e como instalá-lo</li>
    <li>comando git init nós conseguimos criar um repositório Git;</li>
    <li>Como analisar o estado do nosso repositório através do comando git status</li>

</ul>

<hr>
<h2>Iniciando os trabalhos</h2>
<p>Já criamos nosso primeiro repositório, então, se executarmos git status dentro da pasta em que trabalhamos anteriormente, veremos que trata-se de um repositório Git, porém, seu arquivo ainda não está sendo monitorado, ou seja, ele não está salvo no histórico do Git. Para salvarmos uma alteração, ou um arquivo nele, precisaremos que ele monitore o arquivo, e suas mudanças.</p>
<p>Utilizaremos o comando <b>git add "nome do arquivo"</b> no caso de salvar apenas um arquivo, se houvessem mais arquivos não haveria a necessidade de colocar o nome apenas <b>git add .</b> para que todos os arquivos fossem monitorados.</p>
<p>Queremos Queremos salvar as alterações, e o que poderemos entender como sendo um check point para indicar que houve mudança, seria o commit, que precisa ter modificações, que já adicionamos, mas também precisa ter uma mensagem, o que criaremos agora. Por já termos adicionado as modificações a serem enviadas, executaremos simplesmente <b>git commit -m "Criando um arquivo"</b> em que o parâmetro -m serve para passarmos uma mensagem de commit
que será incluído entre aspas. </p>

<hr>
<h2>Saber mais sobre o git status</h2>
<p>Ao executar o comando git status, recebemos algumas informações que talvez não estejam tão claras, principalmente quando nos deparamos com termos como HEAD, working tree, index, etc.</p>
<p>Apenas para esclarecer um pouco, visto que entenderemos melhor o funcionamento do Git durante o treinamento, seguem algumas definições interessantes:</p>

<ul>
<li>HEAD: Estado atual do nosso código, ou seja, onde o Git os colocou</li>
<li>Working tree: Local onde os arquivos realmente estão sendo armazenados e editados</li>
<li>index: Local onde o Git armazena o que será commitado, ou seja, o local entre a working tree e o repositório Git em si.</li>
</ul>
<hr>
<h2>Verificar o histórico de alterações:</h2>
<p>O comando que poderemos utilizar para isto é <b> git log</b>, que nos mostrará diversas informações, sendo o primeiro deles um hash do commit, uma identificação única de cada commit, isto é, não existem dois commits com o mesmo hash. </p>

<h2>Primeira Configuração do git</h2>
<ul>
<li>git config --local user.name "Nome da pessoa"</li>
<li>git config --local user.email "seu@email.aqui"</li>
</ul>

<hr>
<h2>Ignorando arquivos</h2>
<p>Pode acontecer de não querermos que determinado arquivo seja monitorado, como no caso de um arquivo de configurações da IDE. Como poderemos fazer para que o Git o ignore?</p>
<p>Existe um arquivo especial do Git, chamado .gitignore, e todas as linhas que estiverem nele serão lidos e ignorados pelo Git. Se temos um arquivo denominado ide-config que queremos que seja ignorado, por exemplo, basta o incluirmos em .gitignore, digitando ide-config simplesmente. Da mesma forma, se tivéssemos uma pasta ide, incluiríamos ide/, em uma nova linha.
    O nome do arquivo é <b> git add .gitignore</b>.
</p>
<hr>

<h2>Repositório Remoto</h2>

<p>Se executarmos o comando git remote, teoricamente, nada acontece. Mas na verdade, todos os repositórios remotos que o repositório local conhece são listados, que até o momento é nenhum. Portanto, adicionaremos um, com git remote add local C:/Users/ALURA/Documents/git-e-github/servidor, e para quantos repositórios remotos quisermos, poderemos dar algum nome, no caso, local, também incluiremos um caminho, que poderá ser uma URL de um servidor pela internet, um endereço na rede, inclusive de outro computador, qualquer endereço válido para um repositório Git. Neste caso, será uma pasta no próprio servidor.</p>
<p>Depois que pressionamos "Enter", aparentemente nada acontece, e se usarmos o comando git remote, o retorno será local. Se quisermos garantir que o endereço esteja correto, poderemos executar git remote -v, que faz com que o endereço de local seja exibido. Além disso, é indicado que os dados deste caminho serão buscados (fetch), e enviados para este mesmo caminho (push).</p>
<h2>Clonar repositório</h2>
<p>Para clonar um repositório utilizamos o comando <b>git clone "url"</b></p>
<p>Além de adicionar repositórios remotos para sincronizar os dados, vimos que o git clone traz um repositório remoto para o nosso computador, criando um repositório loca</p>

<h2> Enviar as alterações para o repositório remoto</h2>
<p>git push [repositorio] master</p>
<p>Desta forma, nós enviamos as alterações em nosso branch master (falaremos mais sobre branches já já) para o repositório remoto. Basta substituir [repositorio] pelo nome que demos ao repositório ao adicioná-lo. Já para trazer os dados que estiverem no repositório remoto, podemos utilizar o git pull [repositorio] master.</p>
<hr>
<h2>Trabalhando em Equipe</h2>
<p>Branches ("ramos") são utilizados para desenvolver funcionalidades isoladas umas das outras. A branch master é a branch "padrão" quando você cria um repositório.
 É interessante separar o desenvolvimento de funcionalidades em branches diferentes, para que as mudanças no código para uma não influencie no funcionamento de outra.</p>
<p>Usando o Branch.Então, informaremos ao nosso controle de versões que, a partir de um determinado commit, um dos usuários alterará apenas um trecho específico, enquanto o outro usuário informará do seu trecho em desenvolvimento, também. </p>
<p>Estas ramificações do trabalho são uma das formas de com que podemos trabalhar, em relação aos branches do Git. Por padrão, se executarmos git branch no Git Bash, teremos um único branch, master, e é exatamente isto que o Git Bash nos mostra ao fim da linha. No entanto, poderemos criar outros. No caso de trabalharmos somente no título, por exemplo, utilizaremos o comando git branch titulo, que criará este branch, embora tenhamos que mudar para ela manualmente, com git checkout titulo.</p>
<p>Criando um branch  git checkout -b "nome branch"</p>
<p>Subindo a alteração para a nova branch  git push --set-upstream origin aeviles</p>

<p>Diferença entre rebase e merge?</p>
<p>O merge junta os trabalhos e gera um merge commit. O rebase aplica os commits de outra branch na branch atual.</p>

<h2>O que aprendemos</h2>
<ul>
<li>Que uma branch (ou ramo) é uma linha de commits separada, e que pode ser utilizada para desenvolver funcionalidades independentes;</li>
<li>Que com branches separados, podemos evitar que o código de uma funcionalidade interfira em outra;</li>
<li>Como trazer o trabalho realizado em uma branch para outra branch, como por exemplo, o master, através do comando git merge;</li>
<li>Que o git merge gera um novo commit, informando que houve uma mescla entre duas branches;</li>
<li>Como trazer os commits de uma branch para outra, com o git rebase</li>
<li>Que o git rebase não gera um commit de merge, simplificando o nosso log;</li>
<li>Como os conflitos são apresentados pelo Git;</li>
<li>Como resolver os conflitos e manter apenas as alterações desejadas com o Git.</li>
</ul>

<h2>Manipulando as Versões</h2>
<p>Desfazendo alterações : git checkout -- "nome do arquivo que quer desfazer"</p>

<h2>Desfazendo alterações que já foram feitas</h2>
<p>Desfazendo alterações : git reset HEAD index.html </p>

<h2>Desfazendo um commit</h2>
<p> git revert  codigoCommit </p>

<h2>comandos, respectivamente, desfazem alterações antes de adicioná-las (1); depois de adicioná-las, mas antes de commitá-las (2); e após realizar o commit (3)?</h2>
<p>Com o git checkout nós desfazemos uma alteração que ainda não foi adicionada ao index ou stage, ou seja, antes do git add. Depois de adicionar com git add, para desfazer uma alteração, precisamos tirá-la deste estado, com git reset. Agora, se já realizamos o commit, o comando git revert pode nos salvar.</p>
<ul>
<li>git checkout</li>
<li>git reset</li>
<li>git revert</li>
</ul>

<h2>Guardando o código para depois</h2>

<p>git stash :No Git, existe um conceito denominado Stash, e por meio de git stash conseguimos salvar todas as alterações, no caso, somente o arquivo index.html, para um local temporário, sem necessidade de um commit ou de se gerar um commit para isto.Se, após git stash executarmos git stash list, teremos uma lista de tudo que estiver salvo nestas condições. Queremos trazer os dados armazenados pelo git stash ao diretório de trabalho. Há duas opções: executarmos git stash list, e em seguida passarmos o número da stash em git stash apply 0, aplicaremos estas modificações, porém elas continuarão na stash. Para a remoção, poderemos usar git stash drop.  </p>
<p>No caso de querermos fazer ambas as ações ao mesmo tempo, ou seja, pegar a última alteração adicionada à stash, e já removê-la de lá, utilizaremos git stash pop que, ao ser executado, realiza o merge com as modificações que já temos e aplica aquelas que já estavam salvas lá</p>
<p>Em que momento o stash parece útil?Quando precisamos parar o desenvolvimento de algo no meio para trabalhar em outra coisa </p>
<p>Resumidamente, para que serve o comando git checkout?Para deixar o nosso código em determinado estado.</p>
<hr>
<h2>O que aprendemos</h2>,
<ul>
    <li>Que o Git pode nos ajudar a desfazer alterações que não vamos utilizar;</li>
    <li>Que, para desfazer uma alteração antes de adicioná-la para commit (com git add), podemos utilizar o comando git checkout -- <arquivos>;</li>
    <li>Que, para desfazer uma alteração após adicioná-la para commit, antes precisamos executar o git reset HEAD <arquivos> e depois podemos desfazê-las com git checkout -- <arquivos>;</li>
    <li>Que, para revertermos as alterações realizadas em um commit, o comando git revert pode ser a solução;</li>
    <li>Que o comando git revert gera um novo commit informando que alterações foram desfeitas;</li>
    <li>Que, para guardar um trabalho para retomá-lo posteriormente, podemos utilizar o git stash;</li>
    <li>Que, para visualizar quais alterações estão na stash, podemos utilizar o comando git stash list;</li>
    <li>Que, com o comando git stash apply <numero>, podemos aplicar uma alteração específica da stash;</li>
    <li>Que o comando git stash drop <numero> remove determinado item da stash;</li>
    <li>Que o comando git stash pop aplica e remove a última alteração que foi adicionada na stash;
    </li>
    <li>Que o git checkout serve para deixar a cópia do código da nossa aplicação no estado que desejarmos:
        git checkout <branch> deixa o código no estado de uma branch com o nome <branch>;
        git checkout <hash> deixa o código no estado do commit com o hash <hash>.</li>
</ul>


<hr>
<h2>Vendo alterações</h2>
<p>git diff , é necessário incluir o git diff e na proxima linha git diff e o hash</p>
<p>Com o comando git diff, nós vimos que é possível visualizarmos as mudanças realizadas em determinado código. Podemos ver as diferenças entre commits, branches, etc.
Como o git diff exibe as mudanças no código? </p>
<p>+ linha adicionada
    - linha removida
    - linha modificada (versão antiga)
    + linha modificada (nova versão)
<br>
O sinal de subtração (-) antes da linha indica que ela não está mais presente no arquivo. Já o sinal de adição (+) mostra que é uma linha nova. Alterações são representadas por uma remoção e uma adição de linha.
</p>
<hr>
<h2>Tags e Releases</h2>
<p>Podemos utilizar tags no git, para identificar um marco, um ponto que não muda mais na aplicação </p>
<p> git tag -a v0.1.1.0-m "Lançando a primeira versão beta do curso"</p>
<p>Para mostrar a versão digitamos o comando git tag</p>

<p> Estamos utilizando o GitHub, e temos um repositório local denominado origin, que faz menção a ele. Então, atualizaremos nosso código no GitHub com git push origin master. Também enviaremos a tag, com git push origin v0.1.0. Mas como será que visualizamos tags por meio do GitHub? </p>

<p>Que resultado gera o envio de uma tag para o GitHub?Gera uma Release, ou seja, conseguimos baixar um arquivo compactado com o nosso código neste ponto</p>
<hr>
<h1>O que aprendemos</h1>
<ul>
    <li>Que é possível visualizar quais alterações foram realizadas em cada arquivo, com o comando git diff;</li>
    <li>Que, digitando apenas git diff, vemos as alterações em nossos arquivos que não foram adicionadas para commit (com git add);</li>
    <li>Que é possível comparar as alterações entre duas branches com git diff <branch1>..<branch2></branch2></li>
    <li>Que é possível comparar as alterações feitas entre um commit e outro, através do comando git diff <commit1>..<commit2>;</li>
    <li>Que o Git nos possibilita salvar marcos da nossa aplicação, como por exemplo, lançamento de versões, através do git tag;</li>
    <li>Que o comando git tag -a é utilizado para gerar uma nova tag;</li>
    <li>As Releases do GitHub, que são geradas para cada tag do Git criada em nosso repositório.</li>
</ul>
</body>
</html>